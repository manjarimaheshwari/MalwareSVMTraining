import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

public class HMM_Model {
	
	//class vars
	private double[] pi;
	private double[][] A; 
	private double[][] B; 
	private int[] O; 
	private int T;
	private int N;
	private int M;
	
	public int iters = 0;
	public static double oldLogProb = -200000;
	
	public HMM_Model(double[] initPi, double[][] initA, double[][] initB, int[] initO){
	        pi = initPi;
	        A = initA;
	        B = initB;
	        setO(initO);
	        T = getO().length; // number of real observations
	        N = getA().length; 
	        M = B[0].length; 
	}
	
	/**
	 * @return the a
	 */
	public double[][] getA() {
		return this.A;
	}

	/**
	 * @return the B
	 */
	public double[][] getB() {
		return this.B;
	}
	
	/**
	 * @return the pi
	 */
	public double[] getPi() {
		return this.pi;
	}

	/**
	 * @return the o
	 */
	public int[] getO() {
		return O;
	}


	/**
	 * @param o the o to set
	 */
	public void setO(int[] o) {
		O = o;
	}

	/**
	 * @return the t
	 */
	public int getT() {
		return getO().length;
	}
	
	/**
	 * @return the N
	 */
	public int getN() {
		return getA().length;
	}


	public void alpha_pass() {
		double[][] alpha = new double[getT()][getA().length];
		double[] C = new double[getT()];

		// compute a0(i)
		C[0] = 0;
		for (int i = 0; i <= N - 1; i++) {
			alpha[0][i] = pi[i] * B[i][getO()[0]];
			C[0] = C[0] + alpha[0][i];
		}

		// scale the alpha[0][i]
		C[0] = 1 / C[0];
		for (int i = 0; i <= N - 1; i++) {
			alpha[0][i] = C[0] * alpha[0][i];
		}

		// compute alpha[t][i]
		for (int t = 1; t <= getT() - 1; t++) {
			C[t] = 0;
			for (int i = 0; i <= N - 1; i++) {
				alpha[t][i] = 0;
				for (int j = 0; j <= N - 1; j++) {
					alpha[t][i] = alpha[t][i] + (alpha[t - 1][j] * getA()[j][i]);
				}
				alpha[t][i] = alpha[t][i] * B[i][getO()[t]];
				C[t] = C[t] + alpha[t][i];
			}

			// scale alpha[t][i]
			C[t] = 1 / C[t];
			for (int i = 0; i <= N - 1; i++) {
				alpha[t][i] = C[t] * alpha[t][i];
			}
		}
		beta_pass(C, alpha);

	}

	public void beta_pass(double[] C, double[][] alpha) {
		double[][] beta = new double[getT()][getA().length];

		// Let Beta[T-1][i] = 1 scaled by C[T-1]
		for (int i = 0; i <= N - 1; i++) {
			beta[getT() - 1][i] = C[getT() - 1];
		}

		// Beta Pass
		for (int t = getT() - 2; t >= 0; t--) {
			for (int i = 0; i <= N - 1; i++) {
				beta[t][i] = 0;
				for (int j = 0; j <= N - 1; j++) {
					beta[t][i] = beta[t][i] + (getA()[i][j] * B[j][getO()[t + 1]] * beta[t + 1][j]); // corrected Beta[T+1]
				}
				// Scale beta[t][i] with same factor as alpha[t][i]
				beta[t][i] = C[t] * beta[t][i];
			}
		}
		gamma_pass(C, alpha, beta);
	}

	public void gamma_pass(double[] C, double[][] alpha, double[][] beta) {
		// Gamma Pass
		double[][] gamma = new double[getT()][getA().length];
		double[][][] diGamma = new double[getT()][getA().length][getA().length];
		for (int t = 0; t <= getT() - 2; t++) {
			double denom = 0;
			for (int i = 0; i <= N - 1; i++) {
				for (int j = 0; j <= N - 1; j++) {
					denom = denom + (alpha[t][i] * getA()[i][j] * B[j][getO()[t + 1]] * beta[t + 1][j]);
				}
			}
			for (int i = 0; i <= N - 1; i++) {
				gamma[t][i] = 0;
				for (int j = 0; j <= N - 1; j++) {
					diGamma[t][i][j] = (alpha[t][i] * getA()[i][j] * B[j][getO()[t + 1]] * beta[t + 1][j]) / denom;
					gamma[t][i] = gamma[t][i] + diGamma[t][i][j];
				}
			}
		}

		// special case for gamma[T-1][i]
		double denom = 0;
		for (int i = 0; i <= N - 1; i++) {
			denom = denom + alpha[getT() - 1][i];
		}
		for (int i = 0; i <= N - 1; i++) {
			gamma[getT() - 1][i] = alpha[getT() - 1][i] / denom;
		}
		// printArray(C, alpha, beta, gamma);
		re_estimation(C, alpha, beta, gamma, diGamma);
	}

	public void re_estimation(double[] C, double[][] alpha, double[][] beta, double[][] gamma,
			double[][][] diGamma) {
		// re-estimate pi
		for (int i = 0; i <= N - 1; i++) {
			pi[i] = gamma[0][i];
		}

		// re-estimate A
		for (int i = 0; i <= N - 1; i++) {
			for (int j = 0; j <= N - 1; j++) {
				double numer = 0;
				double denom = 0;
				for (int t = 0; t <= getT() - 2; t++) {
					numer = numer + diGamma[t][i][j];
					denom = denom + gamma[t][i];
				}
				getA()[i][j] = numer / denom;
			}
		}

		// re-estimate B
		for (int i = 0; i <= N - 1; i++) {
			for (int j = 0; j < M - 1; j++) {
				double numer = 0;
				double denom = 0;
				for (int t = 0; t <= getT() - 2; t++) {
					if (getO()[t] == j)
						numer = numer + gamma[t][i];
					denom = denom + gamma[t][i];
				}
				B[i][j] = numer / denom;
			}
		}
		computeLog(C);

	}

	public void computeLog(double[] C) {
		// Compute log[P(O | lambda)]
		double logProb = 0;
		for (int i = 0; i <= getT() - 1; i++) {
			logProb = logProb + Math.log(C[i]);
		}
		logProb = -logProb;
		iterate(logProb);
	}

	public void iterate(double logProb) {
		int maxIters = 100;
		iters = iters + 1;
		System.out.println(iters + " LogProb: " + logProb);
		if (iters < maxIters && logProb > oldLogProb) {
			oldLogProb = logProb;
			if (iters == 1) {
				System.out.println("pi: ");
				for (int i = 0; i < pi.length; i++) {
					System.out.print(pi[i] + " ");
				}
				System.out.println("\r\n" + "A: ");
				for (double d : getA()[0])
					System.out.print(d + "");
				for (double d : getA()[1])
					System.out.print(d + "");
				// System.out.print(A[0][0] + " " + A[0][1]);
				// System.out.print("\r\n" + A[1][0] + " " + A[1][1]);

				System.out.println("\r\n" + "B: ");
				// double[][] transB = transpose(B);
				//System.out.println(m.CHARS.keySet());
				for (double d : B[0]) {
					System.out.print(d + "");
				}
				System.out.println();
				for (double d : B[1]) {
					System.out.print(d + "");
				}
			}
			alpha_pass();
		} else {
			System.out.println("pi: ");
			for (int i = 0; i < pi.length; i++) {
				System.out.print(pi[i] + " ");
			}
			System.out.println("\r\n" + "A: ");
			for (double d : getA()[0])
				System.out.print(d + ", ");
			for (double d : getA()[1])
				System.out.print(d + "");
			// System.out.print(A[0][0] + " " + A[0][1]);
			// System.out.print("\r\n" + A[1][0] + " " + A[1][1]);

			System.out.println("\r\n" + "B: ");
			// double[][] transB = transpose(B);
			//System.out.println(m.CHARS.keySet());
			for (double d : B[0]) {
				System.out.print(d + ", ");
			}
			System.out.println("{ ");
			for (double d : B[1]) {
				System.out.print(d + ", ");
			}
		}
	}

	public double[][] transpose(double[][] x) {
		double[][] y = new double[x[0].length][x.length];
		for (int i = 0; i < x[0].length; i++) {
			for (int j = 0; j < x.length; j++) {
				y[i][j] = x[j][i];
			}
		}
		return y;
	}
	


	public static void main(String[] args) {
		// given Model model = (A, B, pi) and Observation set
		// Matrix = #rows * #columns
		// N = # states
		// M = # symbols (possible observations types)
		// A = N x N matrix
		// B = N x M matrix
		// pi = 1 x N matrix or array of length N

		// based on example 1

		//alpha_pass();

		// System.out.println(B.length); // #rows
		// System.out.println(B[0].length); // #columns
		// Loop through all rows
		// for (int i = 0; i < A.length; i++) {
		// Loop through all elements of current row
		// for (int j = 0; j < A[i].length; j++)
		// System.out.print(A[i][j] + " ");
		// }

	}

}
