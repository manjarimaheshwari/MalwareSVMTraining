import java.io.File;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.Scanner;

public class Scoring {

	public static final HashMap<String, String> CHARS = new HashMap<String, String>() {
		{
			put("A", "0");
			put("B", "1");
			put("C", "2");
			put("D", "3");
			put("E", "4");
			put("F", "5");
			put("G", "6");
			put("H", "7");
			put("I", "8");
			put("J", "9");
			put("K", "10");
			put("L", "11");
			put("M", "12");
			put("N", "13");
			put("O", "14");
			put("P", "15");
			put("Q", "16");
			//put("R", "17");
			//put("S", "18");
			//put("T", "19");
			//put("U", "20");
			//put("V", "21");
			// put("W", "22");
			// put("X", "23");
			// put("Y", "24");
			// put("Z", "25");
			// put(" ", "26");
		};
	};


	public static String[] gatherHMMScoringFiles(String[] modelData, int startIndex, int endIndex) {
		String[] testFiles = new String[endIndex - startIndex];
		//System.out.println("modelData 155: " + modelData[155]);
		//System.out.println("LENGTH: " + testFiles.length);
		for (int i = startIndex; i < endIndex; i++) {
			System.out.println("i: " + i);
			System.out.println("testFiles index: " + (i-startIndex));
			System.out.println("modelData: " + modelData[i]);
			testFiles[i-startIndex] = modelData[i];
		}
		//System.out.println(testFiles[155]);
		return testFiles;
	}

	public static int[] defineTrainingO(String[] modelData, int indexNum) {
		String[] trainingArr = modelData[indexNum].split("");
		int[] trainingNum = new int[50000];
		for (int i = 0; i < 50000; i++) {
			trainingArr[i] = trainingArr[i].replace(trainingArr[i], CHARS.get(trainingArr[i]));
			trainingNum[i] = Integer.parseInt(trainingArr[i]);
		}
		return trainingNum;
	}

	// calculate scores of the files on each HMM Model
	public double[] calculateScores(HMM_Model model, String[] testFiles, int obsLength) {
		double[] scores = new double[testFiles.length];
		String observationString = "";
		int[] newO = new int[obsLength];
		for (int i = 0; i < testFiles.length; i++) {
			try {
				//System.out.println(testFiles[i]);
				//System.out.println("File #: " + i + testFiles[i].toString());
				File myObj = new File(testFiles[i].toString());
				Scanner myReader = new Scanner(myObj);
				while (myReader.hasNextLine()) {
					String data = myReader.nextLine();
					observationString = observationString + data;
					// System.out.println(i + "data: " + data);
				}
				myReader.close();
			} catch (FileNotFoundException e) {
				System.out.println("Error reading file: " + i + testFiles[i].toString());
				e.printStackTrace();
			}

			String[] testArr = observationString.split("");
			//System.out.println("length of testArr: " + testArr.length);
			// max length for observation sequence for testing is 5,000
			for (int j = 0; j < Math.min(obsLength, testArr.length); j++) {
				testArr[j] = testArr[j].replace(testArr[j], CHARS.get(testArr[j]));
				// update O for every file
				newO[j] = Integer.parseInt(testArr[j]);
			}
			model.setO(newO);
			//System.out.println(model.getT());
			scores[i] = alpha_pass(model);
			observationString = "";
		}
		//System.out.println("Scores: ");
		//for (double d : scores)
			//System.out.print(d + " ");
		return scores;
	}
	
	public static double alpha_pass(HMM_Model model) {
		double[][] alpha = new double[model.getT()][model.getA().length];
		double[] C = new double[model.getT()];

		// compute a0(i)
		C[0] = 0;
		for (int i = 0; i <= model.getN() - 1; i++) {
			alpha[0][i] = model.getPi()[i] * model.getB()[i][model.getO()[0]];
			C[0] = C[0] + alpha[0][i];
		}

		// scale the alpha[0][i]
		C[0] = 1 / C[0];
		for (int i = 0; i <= model.getN() - 1; i++) {
			alpha[0][i] = C[0] * alpha[0][i];
		}

		// compute alpha[t][i]
		for (int t = 1; t <= model.getT() - 1; t++) {
			C[t] = 0;
			for (int i = 0; i <= model.getN() - 1; i++) {
				alpha[t][i] = 0;
				for (int j = 0; j <= model.getN() - 1; j++) {
					alpha[t][i] = alpha[t][i] + (alpha[t - 1][j] * model.getA()[j][i]);
				}
				alpha[t][i] = alpha[t][i] * model.getB()[i][model.getO()[t]];
				C[t] = C[t] + alpha[t][i];
			}

			// scale alpha[t][i]
			C[t] = 1 / C[t];
			for (int i = 0; i <= model.getN() - 1; i++) {
				alpha[t][i] = C[t] * alpha[t][i];
			}
		}
		return computeLog(C, model.getT());

	}

	public static double computeLog(double[] C, int T) {
		// Compute log[P(O | lambda)]
		double logProb = 0;
		for (int i = 0; i <= T - 1; i++) {
			logProb = logProb + Math.log(C[i]);
		}
		logProb = -logProb;
		return logProb;
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
